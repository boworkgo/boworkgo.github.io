<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>PlaidCTF 2019 Writeup - bowork, go!</title>
<meta name="description" content="4-15-2019 12:10 AM">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="bowork, go!">
<meta property="og:title" content="PlaidCTF 2019 Writeup">
<meta property="og:url" content="http://localhost:4000/2019/04/15/PlaidCTF-2019-Writeup">


  <meta property="og:description" content="4-15-2019 12:10 AM">







  <meta property="article:published_time" content="2019-04-15T00:00:00-04:00">






<link rel="canonical" href="http://localhost:4000/2019/04/15/PlaidCTF-2019-Writeup">













<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="bowork, go! Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--splash landing dark-theme wide">

    <div class="initial-content">
      

<div id="main" role="main">
  <article class="splash" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="PlaidCTF 2019 Writeup">
    <meta itemprop="description" content="4-15-2019 12:10 AM">
    <meta itemprop="datePublished" content="April 15, 2019">
    

    <section class="page__content" itemprop="text">
      <h1 id="4-15-2019-1210-am">4-15-2019 12:10 AM</h1>

<h3 id="docker">Docker</h3>

<p><em>solution.sh</em></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker pull whowouldeverguessthis/public
sudo docker images
sudo docker image inspect whowouldeverguessthis/public
sudo docker ps -a
sudo docker run -it --name testPCTF whowouldeverguessthis/public bash
	grep -rI --exclude-dir=proc --exclude-dir=sys 'PCTF{' .
cd /var/lib/docker/
sudo grep -rI 'PCTF{' .
</code></pre></div></div>

<p>I pulled the docker image (immutable object). Then, I ran the docker container (instance of image) and tried to grep for the flag on it. When that didn’t work, I went to the file location of the docker image on my host and searched the flag there. If the solution doesn’t run automatically, copy and paste the lines one by one to see what they do.</p>

<p>Flag: <code class="highlighter-rouge">PCTF{well_it_isnt_many_points_what_did_you_expect}</code></p>

<h3 id="everland">Everland</h3>

<p><em>everland.sml</em> (Original file)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* 
 *  Setup 
 *
 *In which we define the realm of terror
 *Known as... Everland!
 *)

exception CatFlag of string
exception Malformed
exception GameOver of string

type health = int ref
type strength = int ref

type arena = health * strength * health * strength
type move = string * (arena -&gt; ((unit -&gt; unit) * (unit -&gt; unit)))

type item = (string * (int * int * move list))
type bag = item list ref

datatype Enemy =
  Flag
| Nothing
| Opponent of (health * strength * move list * string * Enemy)
| Init of ((Enemy) -&gt; Enemy)

datatype Player = Hero of (health * strength * move list ref * bag) 

datatype Choice = Fight | Forage | Eat

datatype Colors = RED | BLUE | GREEN | ORANGE | ARB of int

val player_max = 200

val enemy_names = [
  "Wild Balugaloo", 
  "Feral Pewpewpine", 
  "Spatula", 
  "Fearsome Skitterator",
  "Count Dorkula",
  "Splitter Splatter",
  "Elektrikal",
  "Puny Frogpole",
  "Skedankedanker",
  "Skaboose"
]

(* 
 * Helpers 
 *
 *   In which we realize we can never truly
 *   venture out on our own
 *)

fun max (a, b) = if a &gt; b then a else b
fun min (a, b) = if a &lt; b then a else b

val esc = (String.str (Char.chr 27))

(* Request Text from the user *)
fun prompt s =
let
  val _ = TextIO.output(TextIO.stdOut, s^" ")
  val _ = TextIO.flushOut(TextIO.stdOut)
  val result = TextIO.inputLine TextIO.stdIn
in
  case result
of NONE =&gt; raise (GameOver "EOF received")
 | SOME x =&gt; String.substring(x, 0, (String.size x)-1)
end

(* Fun with ansi escape codes (tm) *)
fun get_color x = esc^"[38;5;"^(Int.toString x)^"m"

fun color s c =
 (case c
of RED =&gt; get_color 160
 | BLUE =&gt; get_color 33
 | GREEN =&gt; get_color 42
 | ORANGE =&gt; get_color 202
 | ARB x =&gt; get_color x)^s^
 esc^"[0m"

fun smult s 0 = ""
  | smult s n = 
 if n &lt; 0 then "" 
  else s^(smult s (n-1))

(* There's probably a built-in for div with ceil, but eh *)
fun cdiv (x, y) =
let
  val d = x div y
in
  if (d * y) &lt;&gt; x then d+1 else d
end

infix 5 cdiv 



(* MLton and SML/NJ use different Random libraries so we have this instead *)
val rng = ref (Int.fromLarge ((Time.toMilliseconds (Time.now ()))
   mod (Int.toLarge (List.length enemy_names))))

fun getIdx () =
  (rng := ((!rng) * 1001017) mod (List.length enemy_names);
   !rng)

(* Global Definitions *)
val should_capture = ref false

val has_captured = ref false

val captured = ref Nothing

val posessing = ref false

val name = prompt ("Welcome, mighty hero, to the abyss of "
^(color "Everland" BLUE)^". Pray tell, "
^"what is your name?")

val _ = TextIO.print "\n"

(* No Peeking! *)

fun get_flag () =
  "pctf{Fake flag: please run on server}"

(* 
 * Attacks 
 *
 *   In which we hone our skills and
 *   prepare to do battle
 *)

fun kill_fn (my_h, my_s, their_h, their_s) =
let
  val h = !their_h
in
  (* It kills you. You're dead *)
  ((fn () =&gt; their_h := 0), (fn () =&gt; their_h := h))
end 

fun lunge_fn (my_h, my_s, their_h, their_s) =
let
  val th = !their_h
  val mh = !my_h
in
  (fn () =&gt; (their_h := 2*(!their_h) div 3; my_h := max(!my_h-10, 0)),
   fn () =&gt; (their_h := th; my_h := mh))
end

fun strike_fn (my_h, my_s, their_h, their_s) =
let
  val th = !their_h
in
  (fn () =&gt; (their_h := (max((!their_h)-15, 0))), fn () =&gt; (their_h := th))
end

fun empower_fn (my_h, my_s, their_h, their_s) =
let
  val mh = !my_h
  val ms = !my_s
in
  (fn () =&gt; (my_s := (!my_s + 20); my_h := max(!my_h - 20, 0)),
   fn () =&gt; (my_s := ms; my_h := mh))
end

fun recoup_fn (my_h, my_s, their_h, their_s) =
let
  val mh = !my_h
  val ms = !my_s
in
  (fn () =&gt; (my_s := max(!my_s - 20, 0); my_h := (!my_h + 10)),
   fn () =&gt; (my_s := ms; my_h := mh))
end

fun capture_fn (my_h, my_s, their_h, their_s) =
  ((fn () =&gt; should_capture := true), 
   (fn () =&gt; should_capture := false))

fun stink_fn (my_h, my_s, their_h, their_s) =
let
  val ts = !their_s
in
  (fn () =&gt; (their_s := max(!their_s - 10, 0)),
   fn () =&gt; (their_s := ts))
end

fun wrap_fn (my_h, my_s, their_h, their_s) =
let
  val th = !their_h
  val ts = !their_s
in
  (fn () =&gt; (their_s := max(!their_s - 5, 0); their_h := max(!their_h - 5, 0)),
   fn () =&gt; (their_s := ts; their_h := th))
end

fun pass_fn _ =
  (fn () =&gt; (), fn () =&gt; ())

val strike = ("Sword Strike", strike_fn)
val kill  = ("Death Wave", kill_fn)
val lunge = ("Spear Lunge", lunge_fn)
val empower = ("Full Empower", empower_fn)
val pass = ("Skip Turn", pass_fn)
val recoup = ("Recouperate", recoup_fn)
val capture = ("Capture", capture_fn)
val stink = ("Stink Out", stink_fn)
val wrap = ("Vine Wrap", wrap_fn)

(* Ok this is a hack. But at least I admit that *)
val nop = (0.0, ("Pass", fn () =&gt; ()))

(* 
 * Control Flow Logic 
 * 
 *   In which we weave a thrilling tale
 *   Of pain sorrow, and pwnage
 *)

fun get_opt () =
let
  val opt = prompt( 
"Are you ready for your next fight? You can:\n"
   ^"  - "^(color "fight\n" GREEN)
   ^"  - "^(color "forage\n" GREEN)
   ^"  - "^(color "use\n" GREEN)
   ^"  &gt;")
in
  if opt = "fight" then Fight else
  if opt = "forage" then Forage else
  if opt = "use" then Eat else
  (TextIO.print "Sorry, what was that?\n"; get_opt())
end

fun state_heuristic (arena as (my_h, my_s, their_h, their_s)) (n, move_fn) =
let
  val (activate, deactivate) = move_fn arena
  val _  = activate ()
  val mh = real(!my_h)
  val ms = real(!my_s)
  val th = real(!their_h)
  val ts = real(!their_s)
  val _  = deactivate ()
in
  ((ms/ts) + 3.0*(mh/th), (n, activate))
end 

(* Looks like a garbage collector spilled their load *)
fun print_stats (Hero(p_h, p_s, p_ms, bag)) (Opponent(e_h, e_s, e_ms, e_name, _)) =
  TextIO.print (
"\n"^name^" ("^(color ((Int.toString (!p_s))^"st") GREEN)^") ["^
  (smult (color "|" GREEN) (((!p_h) * 10 div player_max ))) ^
  (smult " " (((player_max - (!p_h)) * 10 cdiv player_max))) ^ "] -- "^
e_name^" ("^(color ((Int.toString (!e_s))^"st") RED)^"): "^
(color ((Int.toString (!e_h))^"hp") RED)^"\n\n"
  )
  | print_stats _ _ = ()

fun get_choice opts col =
  let 
val move_names = List.map (fn (n, _) =&gt; color n col) opts
val (_, move_str) = List.foldl (fn (name, (n, msg)) =&gt;
  (n+1, msg^"  - ("^(Int.toString n)^") "^name^"\n")) (0, "") move_names
val _ = TextIO.print (move_str^"\n")
val choice = Int.fromString (prompt "&gt;") 
  in
case choice
  of NONE =&gt; get_choice opts col
   | SOME x =&gt; get_elmt x opts opts col
  end
and get_elmt n [] opts col = get_choice opts col
  | get_elmt 0 (move::ms) _ _ = move
  | get_elmt n (_::ms) opts col = get_elmt (n-1) ms opts col


(* Fight! Fight! Fight! Fight! *)
fun fight (hero as Hero(p_h, p_s, p_ms, bag)) 
  (enemy as (Opponent (e_h, e_s, e_ms, e_name, next))) =
let
  val _ =
  if (!posessing) then
(posessing := false;
 TextIO.print ("An "^(color "eerie" RED)^" wind rushes past, and"
  ^" a fallen foe rises again...\n\n"))
  else
  let
val arena = (e_h, e_s, p_h, p_s)
val options = List.map (state_heuristic arena) e_ms
val (_, (name, activate)) = List.foldl (fn (ad as (a, _), bd as (b, _)) =&gt;
  if a &gt; b then ad else bd) nop options
val _ = TextIO.print (e_name^" used "^name^"!\n")
  in
activate () 
  end
in
  if (!p_h) &lt;= 0 then
raise GameOver "You Died!"
  else
let
  val _ = print_stats hero enemy
  val _ = TextIO.print "Available Moves:\n"
  val (name, init) = get_choice (!p_ms) RED
  val _ = TextIO.print ("Using: "^(color name RED)^"\n")
  val (act, _) = init (p_h, p_s, e_h, e_s)
  val _ = act()
  val _ = if (!p_h) &lt;= 0 then
  raise GameOver "You Killed Yourself!"
else ()
in
if (!should_capture) andalso (not (!has_captured)) 
then
  if (!e_h &gt; 50) then
(TextIO.print ("It was too strong, you failed to capture "^
  (color e_name ORANGE));
enemy)
  else
  let
val _ = should_capture := false
val _ = has_captured := true
val _ = captured := enemy
(* Kill them so that you can heal yourself *)
fun sacrifice_fn (my_h, my_s, their_h, their_s) =
  (fn () =&gt; (
 my_h := min((!my_h)+min(!e_h, !my_s*10), player_max);
 e_h  := (!e_h-(!my_h)*10);
 p_ms := List.filter (fn (n, _) =&gt; n &lt;&gt; "Sacrifice") (!p_ms)),
   fn () =&gt; ()) (* Only used by the AI, not us *)
val _ = p_ms := (List.filter (fn (n, _) =&gt; n &lt;&gt; "Capture") (!p_ms))
@[("Sacrifice", sacrifice_fn)]
  in
next
  end
else if (!e_h) &lt;= 0 then (TextIO.print ("You Killed "^(color e_name
  ORANGE)^"!\n"); next) else enemy
end
end
  | fight _ _ = raise Malformed


(* Forage! Forage! Forage... Forage? *)  
fun forage (Hero (_, _, _, bag)) wilderness =
  case (!wilderness)
of [] =&gt; TextIO.print "You look around, but find nothing!\n"
 | ((item as (name, (_, _, _)))::rest) =&gt;
 let
   val _ = TextIO.print ("Collected "^(color name BLUE)^"!\n")
   val _ = bag := (item :: (!bag))
 in
   wilderness := rest
 end

(* Use! Use! Ok, you get the point *)
fun use (hero as Hero(p_h, p_s, p_ms, bag)) =
  case (!bag)
of [] =&gt; TextIO.print "No Available Items!\n"
 | bg =&gt;
let
  val _ = TextIO.print "Available Items:\n"
  val (name, (hp, st, mvs)) = get_choice bg BLUE
  val _ = TextIO.print ("Using: "^(color name BLUE)^"\n")
  val _ = p_h := max(!p_h, hp)
  val _ = p_s := max(!p_s, st)
  val _ = bag := List.filter (fn (n, _) =&gt; n &lt;&gt; name) (bg)
  val _ = p_ms := (!p_ms)@mvs
in
  ()
end

fun play_game hero Flag world _ =
  (TextIO.print ("Wow, looks like you beat all the enemies!\n"
^"Guess you deserve a flag: "); raise (CatFlag (get_flag())))
  | play_game hero (Init f) world original =
play_game hero (f original) world original
  | play_game hero enemy world original =
  case (print_stats hero enemy; get_opt ())
of Fight =&gt; play_game hero (fight hero enemy) world original
 | Forage =&gt; (forage hero world; play_game hero enemy world original)
 | Eat =&gt; (use hero; play_game hero enemy world original)
 (* Needs more: play_game hero enemy world original *)
  
fun find_best (this as (Opponent (_, my_s, _, _, next))) best entity =
  if (!my_s) &gt; best then find_best next (!my_s) this
else find_best next best entity
  | find_best _ _ entity = entity


fun gen_enemies 0 = Init (fn e =&gt;
  case (find_best e 0 Nothing)
of (Opponent (health, strength, _, name, _)) =&gt;
   (health:= max((!strength)*5, 250);
strength  := max((!strength)*5, 250);
posessing := true;
Opponent (health, strength, [kill], "Posessed "^name, Flag))
 | _ =&gt; raise (GameOver "Boooo, the phantom never appeared...."))
  | gen_enemies n = Opponent(ref 80, ref 50, [
lunge, 
strike, 
empower, 
recoup
  ], List.nth (enemy_names, getIdx ()), gen_enemies (n-1))

fun start () =
let
  val wilderness = ref [
("Gross Weed", (20, 20, [stink])),
("Risky Dust", (0, 35, [])),
("Random Vines", (50, 0, [wrap])),
("Sacrificial Net", (0, 0, [capture])),
("Lucky Elixir", (100, 100, []))
  ]
  (* Hey, count yourself lucky. I could have made it 100 *)
  val num_enemies = 10

  val hero = Hero(ref 200, ref 100, ref [strike, empower, recoup, pass], 
ref [("Max Health Potion", (200, 0, [])), ("Sharpened Dagger", (0, 100, []))])

  val _ = TextIO.print ("Well, "^(color name GREEN)^". It is valiant of you to venture here, but "
^(color "Everland" BLUE)^" is a place of darkness and despair.\nFew adventurers "
^"have dared descend these halls, and fewer have returned alive.\n"
^"Good luck, and godspeed.\n\n")

  val enemies = gen_enemies num_enemies
  val _ = (play_game hero enemies wilderness enemies)
handle (GameOver msg) =&gt; (TextIO.print (color ("GameOver: "^msg) RED))

  val _ = TextIO.print "\nAnd thus, another passes to dust...\n"
in
  ()
end

(* 
 * Start
 * 
 *   In which our tale thusly begins
 *   Join us, dear friend
 *) 

val _ = start()
  handle (CatFlag f) =&gt; TextIO.print (color (f^"\n\n") (ARB 200))
</code></pre></div></div>

<p><em>solution.py</em></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from pwn import *

r = remote('everland.pwni.ng', '7772')
r.sendline('Greg')
for x in range(79):
r.sendline('fight')
r.sendline('2')
for x in range(5):
r.sendline('forage')
r.sendline('use')
r.sendline('2')
r.sendline('use')
r.sendline('1')
r.sendline('use')
r.sendline('3')
r.sendline('fight')
r.sendline('4')
r.sendline('use')
r.sendline('1')
r.sendline('fight')
r.sendline('5')
r.sendline('fight')
r.sendline('5')
r.interactive()
</code></pre></div></div>

<p>First, I noticed that recuperating in every turn would let me defeat all the monsters except for the final one, denoted by the keyword Possessed. I also noticed the game is relatively constant except for the names and 1 or so differences in health bars. I also noticed that once the Possessed monster started his Death Wave attack, I would not be able to survive it. So I had to defeat it before it could start it.</p>

<p>I found a function in the game called <code class="highlighter-rouge">Sacrifice</code>. I needed to activate it by altering original health of the Possessed monster. I found the health of the Possessed monster was defined by <code class="highlighter-rouge">max((!strength)*5, 250)</code>, so I needed to alter the former parameter. I could do that by capturing the monster early with a net (you’re always guaranteed a capture if the monster has health less than 40) while the monster’s health wasn’t <code class="highlighter-rouge">50</code> so I could escape the default parameter. So I needed to vine wrap him before, reducing his health by 5, and let him full empower on his next turn, making his strength 65. By capturing the monster now, his Possessed form would make his health bar <code class="highlighter-rouge">65 * 5 = 325</code>, enabling the <code class="highlighter-rouge">Sacrifice</code> function, enabling us to defeat the Possessed monster!</p>

<p>Flag: <code class="highlighter-rouge">PCTF{just_be_glad_i_didnt_arm_cpt_hook_with_GADTs}</code></p>

    </section>
  </article>
</div>

    </div>

    

    
  <script src="/assets/js/main.min.js"></script>
  <script data-search-pseudo-elements defer src="https://use.fontawesome.com/releases/v5.7.1/js/all.js" integrity="sha384-eVEQC9zshBn0rFj4+TU78eNA19HMNigMviK/PU/FFjLXqa/GKPgX58rvt5Z8PLs7" crossorigin="anonymous"></script>








  </body>
</html>
